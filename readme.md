# Itertools

В этом проекте реализовано несколько вспомогательных функций для работы с последовательностями, подобных тем, что
есть в языке Python.

А именно `Range`, `Zip` и `Group`.
Примеры того, что планировалось получить в итоге:

```c++
std::vector<int> first{4, 4, 5};
std::list<std::string> second{"aba", "caba"};

for (const auto& elem : Zip(first, second)) {
    // elem.first -> int
    // elem.second -> string
}

for (const auto& elem : Zip(second, Range(second.size()))) {
    // like enumerate
    // elem.first -> string
    // elem.second -> index: 0, 1, 2, ...
}

for (const auto& elem : Group(first)) {
    // elem groups equal elements
    for (const auto& val : elem) {
        // only equal elements here
    }
}
```

Важно то, что все эти функции не создают новых контейнеров, векторов и прочего. Все реализуется посредством итераторов, т.е.
`Range(100500)` не создает вектор из кучи элементов, а возвращает некоторую сущность, по которой можно проитерироваться (как в Python3).

В качестве такой сущности используется класс `IteratorRange`, определенный в `itertools.h`. Данный класс содержит в себе пару
итераторов (начало и конец последовательности). Основное его назначение --- возвращать из функции как результат, который потом можно
использовать в range-based for (как в примерах выше).

Функция `Range(from, to, step)` порождает последовательность `from, from + step, ..., from + k * step`, где `k` --- такое
последнее, что `from + k * step < to`. Реализованы также сокращенные формы `Range` с 1 и 2 аргументами.

Функция `Zip` принимает 2 последовательности (у каждой из которых есть `begin` и `end`) и порождает последовательность соответствующих
пар. При этом функция обрезает итоговую последовательность до наименьшей, т.е.

```c++
std::vector<int> a{1, 2, 3};
for (const auto& val : Zip(a, Range(1 << 30))) {
    // 3 итерации
}
```

Функция `Group` возвращает последовательность из `IteratorRange` на идущие подряд подпоследовательности из равных элементов.

